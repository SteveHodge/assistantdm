package monsters;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.swing.SwingUtilities;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import gamesystem.AC;
import gamesystem.AbilityScore;
import gamesystem.Attacks;
import gamesystem.CharacterClass;
import gamesystem.CharacterClass.LevelUpAction;
import gamesystem.Feat;
import gamesystem.Feat.FeatDefinition;
import gamesystem.HPs;
import gamesystem.ImmutableModifier;
import gamesystem.Modifier;
import gamesystem.SavingThrow;
import gamesystem.Size;
import gamesystem.core.OverridableProperty;
import gamesystem.dice.DiceList;
import monsters.Monster.MonsterAttackForm;
import monsters.Monster.MonsterAttackRoutine;
import monsters.StatisticsBlock.AttackRoutine;
import monsters.StatisticsBlock.Field;
import monsters.StatisticsBlock.MonsterDetails;

// StatsBlockCreatureView is an adapter that provides a traditional statistics block style view of a Monster.
// Because listeners register with this class, there is the potential for updates to be missed if there are
// events generated by this view that do not generate events in the underlying Monster - only listeners of the
// event-generating instance would receive the event. There are two ways to avoid this issue: either ensure that
// all notifiable changes trigger an event on the monster, or ensure that only one instance of the view is
// created for each instance of a monster. Currently the second method is implemented but it might be limiting.
// The first method is generally in use too (as most field changes affect Monster properties that are notified).
// Attack and Full Attack changes, however, only generate property change events on the field (this should probably
// be changed).

public class StatsBlockCreatureView {
	private static Map<Monster, StatsBlockCreatureView> views = new HashMap<>();

	private Monster creature;

	private final PropertyChangeSupport pcs = new PropertyChangeSupport(this);

	private StatsBlockCreatureView(Monster c) {
		creature = c;
		creature.addPropertyListener("", e ->
		SwingUtilities.invokeLater(() -> {
			// FIXME test this is right
			// XXX seem to need to invokeLater() but I don't think it should be necessary
			// TODO recheck without invokeLater - perhaps the issue was caused by multiple view instances
			String source = e.source.getName();
			//System.out.println("StatsBlockCreatureView property listener: Update for '" + source + "' to '" + e.source.getValue() + "'");

			pcs.firePropertyChange(source, null, e.source.getValue());	// XXX necessary?

			// need to generate events for the fields that are built from statistics
			// TODO need to handle attacks somehow
			if (e.source.equals(c.getInitiativeStatistic())) {
				pcs.firePropertyChange(Field.INITIATIVE.name(), null, getField(Field.INITIATIVE));
			} else if (source.startsWith("ac")) {
				pcs.firePropertyChange(Field.AC.name(), null, getField(Field.AC));
			} else if (source.startsWith("ability_score")) {
				pcs.firePropertyChange(Field.ABILITIES.name(), null, getField(Field.ABILITIES));
			} else if (source.startsWith("saving_throw")) {
				pcs.firePropertyChange(Field.SAVES.name(), null, getField(Field.SAVES));
			} else if (e.source.equals(creature.getSizeStatistic())) {
				pcs.firePropertyChange(Field.SIZE_TYPE.name(), null, getField(Field.SIZE_TYPE));
			} else if (e.source.equals(creature.getHPStatistic()) || e.source.equals(creature.getHPStatistic().getMaxHPStat()) || e.source.equals(creature.getHitDice())) {
				pcs.firePropertyChange(Field.HITDICE.name(), null, getField(Field.HITDICE));
			} else if (e.source.equals(creature.getBAB())) {
				pcs.firePropertyChange(Field.BASE_ATTACK_GRAPPLE.name(), null, getField(Field.BASE_ATTACK_GRAPPLE));
				pcs.firePropertyChange(Field.ATTACK.name(), null, getField(Field.ATTACK));
				pcs.firePropertyChange(Field.FULL_ATTACK.name(), null, getField(Field.FULL_ATTACK));
			} else if (source.equals("name")) {
				pcs.firePropertyChange(Field.NAME.name(), null, getField(Field.NAME));
			} else {
				Field f = null;
				if (source.startsWith("field."))
					f = Field.fromString(source.substring(6));
				if (f != null) {
//					System.out.println("Update to field " + f + " (from " + fieldName + ")");
					pcs.firePropertyChange(f.name(), null, e.source.getValue());
				} else {
					//System.out.println("  ^ update was unused (source = [" + e.source + "])");
				}
			}
		}));
	}

	public static StatsBlockCreatureView getView(Monster c) {
		if (views.containsKey(c)) return views.get(c);
		StatsBlockCreatureView v = new StatsBlockCreatureView(c);
		views.put(c, v);
		return v;
	}

	public void addPropertyChangeListener(PropertyChangeListener listener) {
		//System.out.println(this + " addPropertyChangeListener");
		pcs.addPropertyChangeListener(listener);
	}

	public void removePropertyChangeListener(PropertyChangeListener listener) {
		pcs.removePropertyChangeListener(listener);
	}

	public String getName() {
		return creature.getName();
	}

	public String getMonsterName() {
		if (creature.statisticsBlock == null) return null;
		return creature.statisticsBlock.getName();
	}

	public static Monster createMonster(StatisticsBlock blk) {
		String name = blk.getName();

		int[] abilities = new int[6];
		int i = 0;
		for (AbilityScore.Type t : AbilityScore.Type.values()) {
			abilities[i++] = blk.getAbilityScore(t);
		}

		Monster m = new Monster(name, abilities);

		// need these for hitdice, which will want to update when race is set
		m.setProperty("field." + Field.SPECIAL_QUALITIES.name(), blk.get(Field.SPECIAL_QUALITIES));
		m.setProperty("field." + Field.SPECIAL_ATTACKS.name(), blk.get(Field.SPECIAL_ATTACKS));

		m.race.setType(blk.getType());
		for (String s : blk.getSubtypes()) {
			m.race.addSubtype(s);
		}

		Map<CharacterClass, Integer> lvls = blk.getClassLevels();
		for (CharacterClass c : lvls.keySet()) {
			int l = lvls.get(c);
			if (l >= 1) {
				int old = m.level.getLevel();
				m.level.setLevel(old + l);
				for (i = old + 1; i <= m.level.getLevel(); i++) {
					m.level.setClass(i, c);
					Set<LevelUpAction> actions = c.getActions(m.level.getClassLevel(c));
					//System.out.println("Applying actions for " + c + " level " + m.level.getClassLevel(c));
					for (LevelUpAction action : actions) {
						action.apply(m);
					}
				}
			}
		}

//		for (SavingThrow.Type t : SavingThrow.Type.values()) {
//			SavingThrow s = m.getSavingThrowStatistic(t);
//			int save = blk.getSavingThrow(t);
//			if (save > Integer.MIN_VALUE) {
//				s.setBaseOverride(save - s.getValue());
//			}
//		}

		m.hitDice.setHitDice(blk.getHitDice());

		HPs hps = m.getHPStatistic();
		hps.getMaxHPStat().addOverride(blk.getDefaultHPs());

		Size size = m.getSizeStatistic();
		size.setBaseSize(blk.getSize());
		size.setBaseReach(blk.getReach());
		size.setBaseSpace(blk.getSpace());

		// TODO should apply armor and shield bonuses correctly
		AbilityScore dex = m.getAbilityStatistic(AbilityScore.Type.DEXTERITY);
		AC ac = m.getACStatistic();
		Set<Modifier> acMods = blk.getACModifiers();
		for (Modifier mod : acMods) {
			if (mod.getType().equals(AbilityScore.Type.DEXTERITY.name())) {
				if (dex == null) {
					System.out.println("WARN: " + blk.getName() + " has dex modifier in AC (" + mod.getModifier() + ") but no dex score");
				} else if (mod.getModifier() < dex.getModifierValue()) {
					// assume that armor is restricting the max dex bonus
					ac.getArmor().setMaxDex(mod.getModifier());
				} else if (mod.getModifier() > dex.getModifierValue()) {
					System.out.println("WARN: " + blk.getName() + " dex modifier in AC (" + mod.getModifier() + ") does not match ability score modifier (" + dex.getModifierValue() + ")");
				}
			} else if (mod.getType().equals(Modifier.StandardType.ARMOR.toString())) {
				ac.getArmor().setBonus(mod.getModifier());
				ac.getArmor().description = mod.getSource();
			} else if (mod.getType().equals(Modifier.StandardType.SHIELD.toString())) {
				ac.getShield().setBonus(mod.getModifier());
				ac.getShield().description = mod.getSource();
			} else if (mod.getType().equals(Modifier.StandardType.NATURAL_ARMOR.toString())) {
				m.race.setNaturalArmor(ac, mod.getModifier());
			} else if (mod.getType().equals(Modifier.StandardType.SIZE.toString())) {
				// size modifier should already be set up
				if (mod.getModifier() != size.getSizeModifier().getModifier())
					System.out.println("WARN: " + blk.getName() + " size modifier in AC (" + mod.getModifier() + ") does not match size field modifier (" + size.getSizeModifier().getModifier() + ")");
			} else {
				if (mod.getType().equals(AbilityScore.Type.WISDOM.name())) {
					AbilityScore wis = m.getAbilityStatistic(AbilityScore.Type.WISDOM);
					if (wis == null) {
						System.out.println("WARN: " + blk.getName() + " has wis modifier in AC (" + mod.getModifier() + ") but no wis score");
					} else {
						mod = wis.getModifier();
					}
				}
				ac.addModifier(mod);
			}
		}

		m.statisticsBlock = blk;
		// need feats/special qualities before setting up attacks
		m.setProperty("field." + Field.FEATS.name(), blk.get(Field.FEATS));
		// apply any feats we recognise:
		if (blk.get(Field.FEATS) != null) {
			String[] feats = blk.get(Field.FEATS).split(",(?![^()]*+\\))");	// split on commas that aren't in parentheses
			for (String f : feats) {
				int count = 1;
				boolean bonus = false;
				f = f.trim();
				//System.out.print("  '" + f + "': ");
				if (f.endsWith("B")) {
					f = f.substring(0, f.length() - 1);
					bonus = true;
					//System.out.print("bonus feat, ");
				}
				if (f.contains("(")) {
					try {
						count = Integer.parseInt(f.substring(f.indexOf("(") + 1, f.indexOf(")")));
					} catch (NumberFormatException e) {
						// assume if it's not a number then it's a subtype
					}
					f = f.substring(0, f.indexOf("(")).trim();
					//System.out.print("stripped specialisation/count leaving '" + f + "', ");
				}
				f = f.trim();
				if (f.equals("—")) continue;
				FeatDefinition def = Feat.getFeatDefinition(f);
				if (def != null) {
					//System.out.println("Found " + def.name + ", count = " + count);
					for (int j = 0; j < count; j++) {
						Feat feat = def.getFeat();
						feat.bonus = bonus;
						feat.apply(m);
						m.feats.add(feat);
					}
				} else {
					System.out.println("Couldn't find feat '" + f + "'");
				}
			}
		}

		m.getInitiativeStatistic().setValue(blk.getInitiativeModifier() - m.getInitiativeStatistic().getValue());	// set the base value to whatever is unaccounted for

		setAttackList(m, blk.getAttacks(false));
		setFullAttackList(m, blk.getAttacks(true));

		// add racial modifier to grapple (if any)
		List<Modifier> mods = blk.getGrappleModifiers();
		for (Modifier mod : mods) {
			if (mod.getType().equals("racial")) {
				m.getGrappleModifier().addModifier(mod);
			} else {
				// TODO handle dex modifier. dex can either replace strength or the highest can be used. could possibly assume the later. tricky to replace the strength mod though
				System.out.println(blk.getName() + " unimplemented grapple modifier: " + mod + " from '" + blk.get(Field.BASE_ATTACK_GRAPPLE) + "'");
			}
		}

		// add fields we don't use as extra properties:
		m.setProperty("field." + Field.CLASS_LEVELS.name(), blk.get(Field.CLASS_LEVELS));
		m.setProperty("field." + Field.SPEED.name(), blk.get(Field.SPEED));
		m.setProperty("field." + Field.SKILLS.name(), blk.get(Field.SKILLS));
		m.setProperty("field." + Field.ENVIRONMENT.name(), blk.get(Field.ENVIRONMENT));
		m.setProperty("field." + Field.ORGANIZATION.name(), blk.get(Field.ORGANIZATION));
		m.setProperty("field." + Field.CR.name(), blk.get(Field.CR));
		m.setProperty("field." + Field.TREASURE.name(), blk.get(Field.TREASURE));
		m.setProperty("field." + Field.ALIGNMENT.name(), blk.get(Field.ALIGNMENT));
		m.setProperty("field." + Field.ADVANCEMENT.name(), blk.get(Field.ADVANCEMENT));
		m.setProperty("field." + Field.LEVEL_ADJUSTMENT.name(), blk.get(Field.LEVEL_ADJUSTMENT));

		m.hitDice.updateBonusHPs(m);	// doing this last because it may use special attacks

		return m;
	}

	static void setAttackList(Monster m, List<AttackRoutine> attacks) {
		m.attackList = getAttackList(m, attacks);
	}

	static void setFullAttackList(Monster m, List<AttackRoutine> attacks) {
		m.fullAttackList = getAttackList(m, attacks);
	}

	private static List<MonsterAttackRoutine> getAttackList(Monster m, List<AttackRoutine> attacks) {
		List<MonsterAttackRoutine> list = new ArrayList<>();
		for (AttackRoutine r : attacks) {
			List<MonsterAttackForm> atks = new ArrayList<>();
			for (AttackRoutine.Attack a : r.attacks) {
				atks.add(getMonsterAttackForm(m, r, a));
			}
			list.add(m.new MonsterAttackRoutine(atks));
		}
		return list;
	}

	private static MonsterAttackForm getMonsterAttackForm(Monster m, AttackRoutine r, AttackRoutine.Attack a) {
		MonsterAttackForm f = m.new MonsterAttackForm();
		Attacks attacks = m.getAttacksStatistic();

		f.description = a.description;
		f.number = a.number;
		f.touch = a.touch;
		f.automatic = a.automatic;
		f.damageExtra = a.damageExtra;
		f.damageParsed = a.damageParsed;
		f.damageByWeapon = a.byWeapon;

		if (!a.automatic) {
			a.calculateAttackBonus();	// TODO currently need this to set the enhancement bonus correctly. should move that code
			f.attack = attacks.addAttackForm(a.description);
			f.attack.natural = !a.manufactured;
			f.attack.primary = a.primary;
			f.attack.twoWeaponFighting = r.has_mfg_primary && r.has_mfg_secondary;
			if (f.attack.twoWeaponFighting) {
				if (f.attack.primary && !f.attack.natural) {
					f.attack.offhandLight = !r.has_non_light_secondary;
				} else if (!f.attack.primary && (f.attack.natural || !a.non_light)) {
					f.attack.offhandLight = true;
				}
			}
			f.attack.ranged = a.ranged;
			f.attack.canUseDex = a.weaponFinesseApplies;
			f.attack.strLimit = a.strLimit;
			f.attack.maxAttacks = a.attackBonuses.length;
//		attack.noStrPenalty =
//		attack.doublePADmg =
			f.attack.setSize(m.getSizeStatistic().getBaseSize());
			if (a.damageParsed) {
				if (!a.byWeapon) f.attack.setBaseDamage(a.damageDice);
				else {
					System.err.println("Damage not set for " + m.getName() + " because it's 'by weapon'");
				}
				f.attack.strMultiplier = a.strMultiplier;
				f.damageCritical = a.damageCritical;
				f.attack.weaponSpecApplies = a.weaponSpecApplies;
			}

			for (String mod : a.modifiers.keySet()) {
				f.attack.addModifier(new ImmutableModifier(a.modifiers.get(mod), mod));
			}

			for (String mod : a.damageModifiers.keySet()) {
				f.attack.getDamageStatistic().addModifier(new ImmutableModifier(a.modifiers.get(mod), mod));
			}

			if (a.enhancementBonus != 0)
				f.attack.setAttackEnhancement(a.enhancementBonus);
			else if (a.masterwork) f.attack.setMasterwork(true);

			if (a.weaponFocusApplies) {
				f.attack.addModifier(new ImmutableModifier(1, null, "Weapon Focus"));
			}

			f.attack.updateModifiers();

		} else if (a.damageParsed) {
			// automatic - we're prepending the dice and bonus in reverse order
			if (a.damageBonus != 0) f.damageExtra = a.damageBonus + f.damageExtra;
			if (a.damageBonus > 0) f.damageExtra = "+" + f.damageExtra;
			f.damageExtra = a.damageDice + f.damageExtra;
		}
		return f;
	}

	private OverridableProperty.PropertyValue<Integer> babOverride;

	public void setField(Field field, String value) {
		// TODO remaining parseable fields need to be reparsed - AC

		if (field == Field.ABILITIES) {
			for (AbilityScore.Type t : AbilityScore.Type.values()) {
				int score = StatisticsBlock.parseAbilityScore(value, t);
				AbilityScore ability = creature.getAbilityStatistic(t);
				ability.setBaseValue(score);
			}

		} else if (field == Field.AC) {
//			AbilityScore dex = (AbilityScore) m.getStatistic(Creature.STATISTIC_DEXTERITY);
//			AC ac = (AC) m.getStatistic(Creature.STATISTIC_AC);
//			Set<Modifier> acMods = blk.getACModifiers();
//			for (Modifier mod : acMods) {
//				if (mod.getType().equals(AbilityScore.Type.DEXTERITY.name())) {
//					if (dex == null) {
//						System.out.println("WARN: " + blk.getName() + " has dex modifier in AC (" + mod.getModifier() + ") but no dex score");
//					} else if (mod.getModifier() < dex.getModifierValue()) {
//						// assume that armor is restricting the max dex bonus
//						ac.getArmor().setMaxDex(mod.getModifier());
//					} else if (mod.getModifier() > dex.getModifierValue()) {
//						System.out.println("WARN: " + blk.getName() + " dex modifier in AC (" + mod.getModifier() + ") does not match ability score modifier (" + dex.getModifierValue() + ")");
//					}
//				} else {
//					if (mod.getType().equals(AbilityScore.Type.WISDOM.name())) {
//						mod = ((AbilityScore) m.getStatistic(Creature.STATISTIC_DEXTERITY)).getModifier();
//					}
//					ac.addModifier(mod);
//				}
//			}

		} else if (field == Field.BASE_ATTACK_GRAPPLE) {
			// XXX grapple is currently ignored. should apply an override
			int bab = StatisticsBlock.parseBAB(value);
			OverridableProperty<Integer> babProp = creature.getBAB();
			if (babOverride != null) {
				babProp.removeOverride(babOverride);
			}
			if (bab == babProp.getRegularValue()) {
				babOverride = null;
			} else {
				babOverride = babProp.addOverride(bab);
			}

		} else if (field == Field.INITIATIVE) {
			// sets the base value
			int newBase = StatisticsBlock.parseInitiativeModifier(value) - creature.getInitiativeStatistic().getModifiersTotal();
			if (newBase != creature.getInitiativeStatistic().getBaseValue()) {
				creature.getInitiativeStatistic().setValue(newBase);
			}

		} else if (field == Field.SAVES) {
			for (SavingThrow.Type t : SavingThrow.Type.values()) {
				SavingThrow s = creature.getSavingThrowStatistic(t);
				int save = StatisticsBlock.parseSavingThrow(value, t);
				if (save > Integer.MIN_VALUE) {
					s.setBaseOverride(save - s.getModifiersTotal());
				}
			}
		} else if (field == Field.ATTACK) {
			// TODO this should trigger a property change on the Monster
			setAttackList(creature, StatisticsBlock.parseAttacks(value, new MonsterDetails(creature)));
			pcs.firePropertyChange(Field.ATTACK.name(), null, getField(Field.ATTACK));

		} else if (field == Field.FULL_ATTACK) {
			// TODO this should trigger a property change on the Monster
			setFullAttackList(creature, StatisticsBlock.parseAttacks(value, new MonsterDetails(creature)));
			pcs.firePropertyChange(Field.FULL_ATTACK.name(), null, getField(Field.FULL_ATTACK));
		}

		if (creature.hasProperty("field." + field.name())) {
			System.out.println("Setting property '" + field.name() + "' to '" + value + "'");
			creature.setProperty("field." + field.name(), value);
		} else {
			System.out.println("Monster does not have property '" + field.name() + "'");
		}
	}

	public String getField(Field field) {
		return getField(field, true);
	}

	public String getField(Field field, boolean highlightChanged) {
		StringBuilder s = new StringBuilder();
		if (field == Field.INITIATIVE) {
			if (creature.getInitiativeStatistic().getValue() >= 0) s.append("+");
			s.append(creature.getInitiativeStatistic().getValue());
		} else if (field == Field.AC) {
			s.append(creature.getACStatistic().getValue());
			Map<Modifier, Boolean> map = creature.getACStatistic().getModifiers();
			if (map.size() > 0) {
				s.append(" (");
				boolean first = true;
				for (Modifier m : map.keySet()) {
					if (map.get(m)) {
						if (first) {
							first = false;
						} else {
							s.append(", ");
						}
						if (AbilityScore.Type.DEXTERITY.toString().equals(m.getType()) || AbilityScore.Type.WISDOM.toString().equals(m.getType())) {
							// use abbreviated modifier descriptions for ability scores as this is the usual practice for stats blocks
							if (m.getModifier() >= 0)
								s.append("+");
							s.append(m.getModifier()).append(" ").append(m.getType().substring(0, 3));
						} else {
							s.append(m);
						}
					}
				}
				s.append(")");
			}
			s.append(", touch ").append(creature.getACStatistic().getTouchAC().getValue()).append(", flat-footed ").append(creature.getACStatistic().getFlatFootedAC().getValue());
		} else if (field == Field.ABILITIES) {
			for (AbilityScore.Type t : AbilityScore.Type.values()) {
				s.append(t.toString().substring(0, 3)).append(" ");
				AbilityScore score = creature.getAbilityStatistic(t);
				if (score != null) {
					s.append(score.getValue());
				} else {
					s.append("-");
				}
				if (t != AbilityScore.Type.CHARISMA) s.append(", ");
			}
		} else if (field == Field.SAVES) {
			for (SavingThrow.Type t : SavingThrow.Type.values()) {
				s.append(t.getAbbreviation()).append(" ");
				SavingThrow save = creature.getSavingThrowStatistic(t);
				if (save != null) {
					if (save.getValue() >= 0) s.append("+");
					s.append(save.getValue());
				} else {
					s.append("-");
				}
				if (t != SavingThrow.Type.WILL) s.append(", ");
			}
		} else if (field == Field.HITDICE) {
			s.append(DiceList.toString(creature.hitDice.getValue())).append(" (");
			if (creature.getHPStatistic().getValue().intValue() != creature.getHPStatistic().getMaxHPStat().getValue().intValue()) {
				s.append(creature.getHPStatistic().getValue()).append("/");
			}
			s.append(creature.getHPStatistic().getMaxHPStat().getValue()).append(" hp)");
		} else if (field == Field.SIZE_TYPE) {
			s.append(creature.getSizeStatistic().getSize());
			s.append(" ");
			s.append(creature.race);
		} else if (field == Field.SPACE_REACH) {
			s.append(creature.getSizeStatistic().getSpace().getValue() / 2);
			if (creature.getSizeStatistic().getSpace().getValue() % 2 == 1) s.append("½");
			s.append(" ft./").append(creature.getSizeStatistic().getReach().getValue()).append(" ft.");
		} else if (field == Field.ATTACK) {
			s.append(getAttackHTML(creature.attackList));
		} else if (field == Field.FULL_ATTACK) {
			s.append(getAttackHTML(creature.fullAttackList));
		} else if (field == Field.BASE_ATTACK_GRAPPLE) {
			if (creature.getBAB().getValue() >= 0) s.append("+");
			s.append(creature.getBAB().getValue()).append("/");

			if (creature.race.hasSubtype("Incorporeal") || creature.race.hasSubtype("Swarm")) {
				s.append("—");
			} else {
				int g = creature.getGrappleModifier().getValue();
				if (g >= 0) s.append("+");
				s.append(g);
			}
		}

		StatisticsBlock stats = creature.statisticsBlock;
		if (s.length() == 0) {
			if (creature.hasProperty("field." + field.name()) && creature.getPropertyValue("field." + field.name()) != null) {
				s.append(creature.getPropertyValue("field." + field.name()));
			} else if (stats != null && stats.get(field) != null) {
				s.append(stats.get(field));
			}
		}

		if (highlightChanged && stats != null && !isEquivalent(field, s.toString())) {
			return "<b>" + s.append("</b>");
		} else {
			return s.toString();
		}
	}

// returns true if the calculated field is apparently the same as the field from the original block.
// several common alternate characters are treated as equal (e.g. various dashes and minus, commas
// and semicolons, etc). Special cases are included for certain fields.
	boolean isEquivalent(Field field, String calculated) {
		StatisticsBlock stats = creature.statisticsBlock;

		if (calculated == null) calculated = "";
		if (stats.get(field) == null && !calculated.equals("")) return false;

		String cleanValue = "";
		if (stats.get(field) != null) cleanValue = stats.get(field).replaceAll("[–—Ø]", "-").replaceAll("\\s+", " ");
		String cleanBuilt = calculated.replaceAll("[–—]", "-");

		if (field == Field.AC) {
			cleanValue = cleanValue.replaceFirst("\\(.*\\)", "()");	// strip modifiers from ac
			cleanBuilt = cleanBuilt.replaceFirst("\\(.*\\)", "()");	// strip modifiers from ac
		} else if (field == Field.ATTACK || field == Field.FULL_ATTACK) {
			cleanValue = cleanValue.replace(";", ",").replace("*", "");
			cleanBuilt = cleanBuilt.replace(";", ",");
		}

//		if (!cleanValue.equals(cleanBuilt)) {
//			System.out.println("   " + cleanValue);
//			System.out.println("!= " + cleanBuilt);
//			System.out.println();
//		}
		return cleanValue.equals(cleanBuilt);
	}

	private String getAttackHTML(List<MonsterAttackRoutine> attackRoutines) {
		StringBuilder b = new StringBuilder();
		for (int i = 0; i < attackRoutines.size(); i++) {
			if (i > 0) {
				b.append("; or ");
			}
			b.append(attackRoutines.get(i));
		}
		return b.toString();
	}

	public String getHTML() {
		StringBuilder s = new StringBuilder();
		s.append("<html><table><tr><td></td><td>").append(getName()).append("</td><td>").append(getName()).append("</td></tr>");

		for (Field p : Field.getStandardOrder()) {
			s.append("<tr><td>").append(p).append("</td><td>");
			s.append(getField(p));
			StatisticsBlock stats = creature.statisticsBlock;
			if (stats != null) s.append("</td><td>").append(stats.get(p));
			s.append("</td></tr>");
		}

		s.append("</table></html>");
		return s.toString();
	}

	public Element getXMLElement(Document doc) {
		Element root = doc.createElement("monster");
		root.setAttribute("name", creature.getName());
		Element stats = doc.createElement("statsblock");
		root.appendChild(stats);
		for (Field f : Field.getStandardOrder()) {
			Element line = doc.createElement(f.getTagName());
			line.setTextContent(getField(f, false));
			stats.appendChild(line);
		}
		return root;
	}
}
